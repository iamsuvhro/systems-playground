### **Day 1: C Compilation and Basic Debugging**

Your first day focused on the fundamentals of turning C code into an executable program and inspecting the result.

*   **Compilation with GCC:** You learned to use the `gcc` compiler with a specific set of flags to ensure code quality and debuggability.
    *   `gcc -Wall -Wextra -O0 -g hello.c -o hello`
    *   `-Wall` & `-Wextra`: Enable all common and extra warnings to catch potential bugs early.
    *   `-O0`: Disables optimization, which makes debugging more predictable.
    *   `-g`: Includes debugging symbols (like variable names and line numbers) in the executable, which is essential for `gdb`.
    *   `-o hello`: Specifies the name of the output executable file.

*   **Inspecting the Binary:** You explored tools to understand the compiled program.
    *   `file hello`: Identifies the type of the file (e.g., "ELF 64-bit LSB executable").
    *   `ldd hello`: Lists the shared libraries the program depends on.
    *   `readelf -h hello`: Shows detailed information from the ELF (Executable and Linkable Format) header.

*   **Basic GDB:** You were introduced to the GNU Debugger.
    *   `gdb ./hello`: Starts a debugging session for your program.
    *   `run`: Executes the program inside the debugger.

### **Day 2: Multi-File Projects and Advanced GDB**

You moved from a single source file to a more structured project with multiple files and deepened your debugging skills.

*   **Separate Compilation and Linking:**
    1.  **Compile:** You compiled individual source files into "object files" (`.o`) without linking them. This is done with the `-c` flag.
        *   `gcc -Wall -Wextra -O0 -g -c main.c`
        *   `gcc -Wall -Wextra -O0 -g -c math_ops.c`
    2.  **Link:** You then linked the generated object files (`main.o`, `math_ops.o`) into a single final executable.
        *   `gcc main.o math_ops.o -o calc`

*   **Advanced GDB Commands:** You learned to control program execution and inspect its state.
    *   `break main`: Sets a breakpoint at the beginning of the `main` function, pausing execution there.
    *   `next`: Executes the current line and moves to the next one (it "steps over" function calls).
    *   `print <variable>`: Displays the current value of a variable. This relies on the debug symbols included with the `-g` flag.

### **Day 3: Pointers in C**

This day was a deep dive into one of C's most powerful and complex features: pointers.

*   **Core Pointer Concepts:**
    *   **Definition (`*`)**: `int *p;` creates a pointer variable `p` that can hold the memory address of an integer. It's good practice to initialize it to `NULL` (`int *p = NULL;`).
    *   **Assignment (`&`)**: `p = &x;` stores the memory address of the variable `x` in the pointer `p`.
    *   **Dereferencing (`*`)**: `*p = 20;` "follows" the address stored in `p` and changes the value at that location.

*   **Pointer Arithmetic:**
    *   `pointer++` doesn't just add 1; it increments the pointer's address by the size of the data type it points to (e.g., `+4` for an `int`, `+1` for a `char`).
    *   Array names are constant pointers, meaning you can't modify them (`array++` is illegal), but you can assign a pointer to them and increment that pointer.

*   **Practical Implementations:** You used pointers to implement your own versions of standard library functions like `strlen` and `strrev`, demonstrating your understanding of memory traversal.

*   **Format Specifiers:** You created a reference table for `printf` specifiers, noting the importance of `%p` for printing addresses and `%zu` for `sizeof` results.

### **Day 4: Dynamic Memory Management**

You learned to manage memory on the heap, which is crucial for creating data structures whose size is not known at compile time.

*   **Stack vs. Heap Memory:** You explored the fundamental difference between the automatically managed stack and the manually managed heap.

*   **Heap Allocation Functions:**
    *   `malloc()`: (Memory Allocation) Allocates a requested number of bytes on the heap. The allocated memory is not cleared and may contain garbage values.
    *   `calloc()`: (Contiguous Allocation) Allocates memory and initializes all bytes to zero, which is safer than `malloc`.
    *   `realloc()`: Resizes a previously allocated block of memory. It can grow or shrink the allocation and may move the entire block to a new location if necessary.

*   **The Golden Rule:** You must `free()` any memory you allocate with `malloc`, `calloc`, or `realloc` when you are done with it to prevent memory leaks.

*   **Valgrind:** You learned to use this powerful tool to automatically detect memory errors.
    *   `valgrind --leak-check=full ./program` is a simple way to check for memory leaks.

*   **`void*` Pointers:** You understood that `malloc` and `calloc` return a "generic" `void*` pointer, which must be cast to the appropriate pointer type (e.g., `(int*)`) before use.

### **Day 5: File I/O: Standard Library vs. System Calls**

You explored the two primary ways to interact with files in C, understanding the trade-offs between them.

*   **Two Levels of File I/O:**
    1.  **Standard C Library (High-Level):**
        *   Functions: `fopen`, `fprintf`, `fgets`, `fclose`.
        *   How it works: These functions use a **buffer** in your program's memory. Writes are collected in the buffer and sent to the OS in larger, more efficient chunks.
        *   Best for: Many small, frequent read/write operations.
    2.  **System Calls (Low-Level):
        *   Functions: `open`, `read`, `write`, `close`.
        *   How it works: These are direct requests to the operating system kernel. Each call involves a "context switch," which has a performance cost.
        *   Best for: Reading or writing large, continuous blocks of data.

*   **Key Concepts:**
    *   **File Descriptor:** When using system calls, an open file is represented by an integer (a file descriptor).
    *   **`perror`:** A crucial function for debugging. When a system call fails, it sets a global `errno` variable. `perror("Error message")` prints your custom message followed by a human-readable description of the system error.
    *   **File Permissions (`0644`):** You learned that the leading `0` in a number signifies an **octal** (base-8) value, which is how file permissions are traditionally represented in Unix-like systems.
